<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prosty i szczegółowy przewodnik po Dockerze</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="docker.css">
   
</head>
<body>
    <div class="container">
        <h1>Rozszerzony i szczegółowy przewodnik po Dockerze</h1>

        <div class="section">
            <h2>1. Co to jest Docker?</h2>
            <p>Docker to platforma do tworzenia, uruchamiania i zarządzania kontenerami. Kontenery to lekkie, izolowane środowiska zawierające wszystko, co potrzebne do uruchomienia aplikacji: kod, runtime, narzędzia systemowe, biblioteki i ustawienia.</p>

            <h3>Główne zalety Dockera:</h3>
            <ul>
                <li><strong>Izolacja aplikacji:</strong> Każdy kontener działa niezależnie, co eliminuje konflikty między aplikacjami i ich zależnościami.</li>
                <li><strong>Łatwe przenoszenie między środowiskami:</strong> Kontenery można łatwo przenosić między różnymi systemami operacyjnymi i chmurami, zachowując spójność działania.</li>
                <li><strong>Szybkie uruchamianie i zatrzymywanie:</strong> Kontenery startują w ciągu sekund, co przyspiesza procesy developerskie i wdrożeniowe.</li>
                <li><strong>Efektywne wykorzystanie zasobów:</strong> W przeciwieństwie do tradycyjnych maszyn wirtualnych, kontenery współdzielą jądro systemu operacyjnego, co zmniejsza zużycie zasobów.</li>
                <li><strong>Skalowalność:</strong> Łatwe skalowanie aplikacji poprzez uruchamianie wielu instancji kontenerów.</li>
                <li><strong>Kontrola wersji:</strong> Możliwość wersjonowania całych środowisk aplikacji, co ułatwia zarządzanie i rollback.</li>
            </ul>

            <h3>Architektura Dockera:</h3>
            <p>Docker składa się z kilku kluczowych komponentów:</p>
            <ul>
                <li><strong>Docker Engine:</strong> Serce systemu Docker, odpowiedzialne za tworzenie i zarządzanie kontenerami.</li>
                <li><strong>Docker Client:</strong> Interfejs wiersza poleceń do interakcji z Docker Engine.</li>
                <li><strong>Docker Registry:</strong> Repozytorium do przechowywania i dystrybucji obrazów Docker (np. Docker Hub).</li>
            </ul>
        </div>

        <div class="section">
            <h2>2. Podstawowe pojęcia</h2>
            
            <h3>Obraz (Image)</h3>
            <p>Obraz Docker to szablon zawierający system operacyjny, aplikację i jej zależności. Obrazy są niemutowalne i budowane warstwowo, co pozwala na efektywne współdzielenie wspólnych warstw między różnymi obrazami.</p>
            <p>Kluczowe cechy obrazów:</p>
            <ul>
                <li>Składają się z wielu warstw, które są cache'owane</li>
                <li>Mogą być budowane na bazie innych obrazów</li>
                <li>Definiowane są przez Dockerfile</li>
                <li>Mogą być przechowywane w rejestrach (np. Docker Hub)</li>
            </ul>

            <h3>Kontener (Container)</h3>
            <p>Kontener to uruchomiona instancja obrazu. Jest to lekkie, samodzielne środowisko wykonawcze dla aplikacji.</p>
            <p>Właściwości kontenerów:</p>
            <ul>
                <li>Mogą być uruchamiane, zatrzymywane, przenoszone i usuwane</li>
                <li>Są izolowane od innych kontenerów i systemu hosta</li>
                <li>Mogą być połączone z innymi kontenerami poprzez sieci Docker</li>
                <li>Mają własny system plików, który jest kombinacją warstw obrazu i warstwy zapisywalnej</li>
            </ul>

            <h3>Dockerfile</h3>
            <p>Dockerfile to plik tekstowy zawierający zestaw instrukcji do budowania obrazu Docker. Definiuje środowisko i konfigurację aplikacji.</p>
            <p>Przykładowe instrukcje Dockerfile:</p>
            <ul>
                <li><code>FROM</code>: Określa bazowy obraz</li>
                <li><code>RUN</code>: Wykonuje polecenia w kontenerze</li>
                <li><code>COPY</code> / <code>ADD</code>: Kopiuje pliki do kontenera</li>
                <li><code>ENV</code>: Ustawia zmienne środowiskowe</li>
                <li><code>EXPOSE</code>: Informuje o portach nasłuchujących kontenera</li>
                <li><code>CMD</code> / <code>ENTRYPOINT</code>: Definiuje domyślne polecenie do uruchomienia</li>
            </ul>

            <h3>Docker Hub</h3>
            <p>Docker Hub to publiczne repozytorium obrazów Docker. Umożliwia przechowywanie, pobieranie i udostępnianie obrazów Docker.</p>
            <p>Funkcje Docker Hub:</p>
            <ul>
                <li>Przechowywanie publicznych i prywatnych obrazów</li>
                <li>Automatyczne budowanie obrazów z kodu źródłowego</li>
                <li>Integracja z systemami kontroli wersji (np. GitHub, Bitbucket)</li>
                <li>Zarządzanie zespołami i organizacjami</li>
            </ul>
        </div>

        <div class="section">
            <h2>3. Podstawowe komendy Dockera</h2>
            
            <h3>Pobieranie obrazu</h3>
            <p class="command">docker pull nginx:latest</p>
            <p>Ta komenda pobiera najnowszą wersję obrazu nginx z Docker Hub. Możesz określić konkretną wersję, zamieniając <code>latest</code> na numer wersji.</p>

            <h3>Uruchamianie kontenera</h3>
            <p class="command">docker run -d -p 8080:80 --name moj_nginx nginx</p>
            <p>Ta komenda uruchamia kontener nginx w tle, mapując port 8080 hosta na port 80 kontenera.</p>
            <p>Opcje:</p>
            <ul>
                <li><code>-d</code>: uruchom w trybie detached (w tle)</li>
                <li><code>-p 8080:80</code>: przekieruj port 8080 hosta na port 80 kontenera</li>
                <li><code>--name moj_nginx</code>: nadaj nazwę kontenerowi</li>
            </ul>
            <p>Dodatkowe przydatne opcje:</p>
            <ul>
                <li><code>-v /sciezka/na/hoscie:/sciezka/w/kontenerze</code>: montuje wolumin</li>
                <li><code>-e ZMIENNA=wartosc</code>: ustawia zmienną środowiskową</li>
                <li><code>--network nazwa_sieci</code>: podłącza kontener do określonej sieci</li>
            </ul>

            <h3>Listowanie kontenerów</h3>
            <p class="command">docker ps</p>
            <p>Wyświetla listę uruchomionych kontenerów.</p>
            <p class="command">docker ps -a</p>
            <p>Wyświetla wszystkie kontenery, włącznie z zatrzymanymi.</p>

            <h3>Zatrzymywanie i usuwanie kontenerów</h3>
            <pre>docker stop moj_nginx
docker rm moj_nginx</pre>
            <p><code>docker stop</code> zatrzymuje działający kontener, a <code>docker rm</code> usuwa go. Możesz użyć ID kontenera zamiast nazwy.</p>
            <p>Aby zatrzymać i usunąć wszystkie kontenery:</p>
            <pre>docker stop $(docker ps -aq)
docker rm $(docker ps -aq)</pre>

            <h3>Wykonywanie poleceń w kontenerze</h3>
            <p class="command">docker exec -it moj_nginx /bin/bash</p>
            <p>Ta komenda pozwala na interaktywne wykonywanie poleceń wewnątrz działającego kontenera.</p>

            <h3>Przeglądanie logów kontenera</h3>
            <p class="command">docker logs moj_nginx</p>
            <p>Wyświetla logi z określonego kontenera. Dodaj opcję <code>-f</code>, aby śledzić logi na żywo.</p>
        </div>

        <div class="section">
            <h2>4. Tworzenie własnych obrazów</h2>
            
            <h3>Struktura Dockerfile</h3>
            <p>Dockerfile to skrypt zawierający instrukcje do budowania obrazu Docker. Oto przykładowy Dockerfile:</p>
            <pre>
# Używamy oficjalnego obrazu nginx jako bazy
FROM nginx:latest

# Kopiujemy pliki naszej aplikacji do kontenera
COPY ./moja_strona /usr/share/nginx/html

# Instalujemy dodatkowe narzędzia
RUN apt-get update && apt-get install -y vim

# Ustawiamy zmienną środowiskową
ENV MY_ENV_VAR=wartosc

# Informujemy, że kontener będzie nasłuchiwał na porcie 80
EXPOSE 80

# Uruchamiamy nginx w trybie foreground
CMD ["nginx", "-g", "daemon off;"]</pre>
            <p>Wyjaśnienie instrukcji:</p>
            <ul>
                <li><code>FROM</code>: Określa bazowy obraz</li>
                <li><code>COPY</code>: Kopiuje pliki z hosta do kontenera</li>
                <li><code>RUN</code>: Wykonuje polecenia podczas budowania obrazu</li>
                <li><code>ENV</code>: Ustawia zmienną środowiskową</li>
                <li><code>EXPOSE</code>: Informuje o portach, na których nasłuchuje aplikacja</li>
                <li><code>CMD</code>: Definiuje domyślne polecenie do uruchomienia kontenera</li>
            </ul>

            <h3>Budowanie obrazu</h3>
            <p class="command">docker build -t moj_obraz:v1 .</p>
            <p>Ta komenda buduje obraz na podstawie Dockerfile w bieżącym katalogu. Opcje:</p>
            <ul>
                <li><code>-t moj_obraz:v1</code>: nadaje nazwę i tag obrazowi</li>
                <li><code>.</code>: wskazuje na bieżący katalog jako kontekst budowania</li>
            </ul>

            <h3>Dobre praktyki tworzenia obrazów</h3>
            <ul>
                <li>Używaj oficjalnych obrazów bazowych</li>
                <li>Minimalizuj liczbę warstw, łącząc polecenia RUN</li>
                <li>Usuwaj niepotrzebne pliki po instalacji pakietów</li>
                <li>Używaj .dockerignore do wykluczania niepotrzebnych plików</li>
                <li>Unikaj instalowania niepotrzebnych pakietów</li>
                <li>Używaj wieloetapowego budowania dla mniejszych obrazów końcowych</li>
            </ul>
        </div>

        <div class="section">
            <h2>5. Tworzenie bezpiecznych obrazów i kontenerów</h2>
            
            <h3>1. Minimalne obrazy bazowe</h3>
            <p>Używaj możliwie najmniejszych obrazów bazowych, takich jak <code>alpine</code>, aby zminimalizować powierzchnię ataku. Mniejsze obrazy mają mniej zależności, co redukuje liczbę potencjalnych luk bezpieczeństwa.</p>
            <pre>
# Przykład użycia obrazu Alpine:
FROM alpine:latest
RUN apk add --no-cache bash
            </pre>

            <h3>2. Regularne aktualizacje i łatki</h3>
            <p>Regularnie aktualizuj obrazy bazowe oraz oprogramowanie w kontenerach, aby zapewnić stosowanie najnowszych poprawek bezpieczeństwa.</p>
            <pre>
# Przykład aktualizacji w Dockerfile:
RUN apt-get update && apt-get upgrade -y
            </pre>

            <h3>3. Zarządzanie uprawnieniami</h3>
            <p>Unikaj uruchamiania aplikacji w kontenerze jako użytkownik <code>root</code>. Zamiast tego twórz użytkowników o ograniczonych uprawnieniach.</p>
            <pre>
# Dodanie nowego użytkownika w Dockerfile:
RUN addgroup -S mygroup && adduser -S myuser -G mygroup
USER myuser
            </pre>

            <h3>4. Izolacja zasobów</h3>
            <p>Ogranicz zasoby dostępne dla kontenerów (CPU, pamięć), aby zapobiec atakom polegającym na przeciążeniu zasobów.</p>
            <pre>
# Przykład w docker-compose.yml:
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
            </pre>

            <h3>5. Bezpieczne zarządzanie sekretami</h3>
            <p>Nie zapisuj tajnych danych (np. kluczy API, haseł) w obrazie. Używaj zmiennych środowiskowych lub menedżerów sekretów, takich jak Docker Secrets.</p>
            <pre>
# Przykład użycia zmiennych środowiskowych w docker-compose.yml:
environment:
  - DATABASE_PASSWORD=${DB_PASSWORD}
            </pre>

            <h3>6. Bezpieczna konfiguracja sieci</h3>
            <p>Izoluj kontenery w oddzielnych sieciach i stosuj firewalle, aby ograniczyć nieautoryzowany dostęp. Docker domyślnie tworzy sieć mostu dla kontenerów, ale możesz stworzyć bardziej zaawansowane sieci.</p>
            <pre>
# Przykład w docker-compose.yml:
networks:
  default:
    external:
      name: my_custom_network
            </pre>

            <h3>7. Skany bezpieczeństwa</h3>
            <p>Regularnie skanuj swoje obrazy pod kątem podatności na ataki za pomocą narzędzi takich jak <code>Trivy</code> czy <code>Clair</code>.</p>
            <pre>
# Przykład skanu za pomocą Trivy:
trivy image myimage:latest
            </pre>

            <h3>8. Kontrola dostępu do hosta</h3>
            <p>Unikaj uruchamiania kontenerów z pełnymi uprawnieniami do systemu hosta, chyba że jest to absolutnie konieczne. Ogranicz dostęp do systemu plików hosta poprzez unikanie opcji <code>--privileged</code>.</p>

            <h3>9. Blokowanie niepotrzebnych uprawnień</h3>
            <p>Użyj opcji <code>--cap-drop</code> i <code>--security-opt</code>, aby usunąć niepotrzebne uprawnienia z kontenerów.</p>
            <pre>
# Przykład uruchomienia kontenera z ograniczonymi uprawnieniami:
docker run --cap-drop=ALL --security-opt=no-new-privileges myimage
            </pre>

            <h3>10. Używanie podpisanych obrazów</h3>
            <p>Używaj podpisanych obrazów Docker i włącz Docker Content Trust (DCT) w celu weryfikacji podpisów obrazów i zapobiegania użyciu nieautoryzowanych obrazów.</p>
            <pre>
# Włączenie Docker Content Trust:
export DOCKER_CONTENT_TRUST=1
            </pre>
        </div>


        <div class="section">
            <h2>6. Docker Compose</h2>
            <p>Docker Compose to narzędzie do definiowania i uruchamiania aplikacji składających się z wielu kontenerów. Używa pliku YAML do konfiguracji usług aplikacji.</p>

            <h3>Struktura docker-compose.yml</h3>
            <pre>
version: '3'
services:
  web:
    build: .
    ports:
      - "8080:80"
    volumes:
      - ./app:/usr/share/nginx/html
    depends_on:
      - db
  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: example
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:</pre>
            <p>Wyjaśnienie kluczowych elementów:</p>
            <ul>
                <li><code>version</code>: Wersja składni Docker Compose</li>
                <li><code>services</code>: Definiuje usługi (kontenery) aplikacji</li>
                <li><code>build</code>: Wskazuje na katalog z Dockerfile</li>
                <li><code>image</code>: Określa gotowy obraz do użycia</li>
                <li><code>ports</code>: Mapuje porty między hostem a kontenerem</li>
                <li><code>volumes</code>: Definiuje wolumeny dla trwałego przechowywania danych</li>
                <li><code>depends_on</code>: Określa zależności między usługami</li>
                <li><code>environment</code>: Ustawia zmienne środowiskowe</li>
            </ul>

            <h3>Podstawowe komendy Docker Compose</h3>
            <p class="command">docker-compose up -d</p>
            <p>Uruchamia wszystkie usługi zdefiniowane w docker-compose.yml w trybie detached (w tle). Jeśli obrazy nie istnieją, zostaną zbudowane.</p>

            <p class="command">docker-compose down</p>
            <p>Zatrzymuje i usuwa wszystkie kontenery, sieci i wolumeny utworzone przez <code>docker-compose up</code>.</p>

            <p class="command">docker-compose ps</p>
            <p>Wyświetla status kontenerów zdefiniowanych w docker-compose.yml.</p>

            <p class="command">docker-compose logs</p>
            <p>Wyświetla logi ze wszystkich usług. Można dodać nazwę usługi, aby zobaczyć logi tylko dla niej.</p>

            <p class="command">docker-compose build</p>
            <p>Buduje lub przebudowuje usługi zdefiniowane w docker-compose.yml.</p>

            <p class="command">docker-compose exec service_name command</p>
            <p>Wykonuje polecenie w działającym kontenerze. Na przykład: <code>docker-compose exec web bash</code></p>

            <h3>Zaawansowane funkcje Docker Compose</h3>
            <ul>
                <li><strong>Skalowanie usług:</strong> <code>docker-compose up -d --scale web=3</code> uruchomi 3 instancje usługi "web".</li>
                <li><strong>Przesłanianie zmiennych środowiskowych:</strong> Można użyć pliku <code>.env</code> do przechowywania zmiennych środowiskowych.</li>
                <li><strong>Rozszerzanie konfiguracji:</strong> Można użyć wielu plików docker-compose, np. <code>docker-compose.yml</code> i <code>docker-compose.override.yml</code>.</li>
                <li><strong>Healthchecks:</strong> Można zdefiniować testy sprawdzające zdrowie kontenera.</li>
            </ul>

            <h3>Przykład rozbudowanego docker-compose.yml</h3>
            <pre>
version: '3.8'
services:
  web:
    build: 
      context: ./frontend
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    environment:
      - REACT_APP_API_URL=http://api:5000
    depends_on:
      - api
  
  api:
    build: ./backend
    ports:
      - "5000:5000"
    environment:
      - DATABASE_URL=postgres://user:password@db:5432/mydb
    depends_on:
      db:
        condition: service_healthy
  
  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=mydb
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mydb"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:

networks:
  default:
    name: myapp_network</pre>

            <p>Ten przykład pokazuje bardziej zaawansowaną konfigurację z frontendem, backendem i bazą danych, wraz z healthchecks i niestandardową siecią.</p>

            <h3>Dobre praktyki używania Docker Compose</h3>
            <ul>
                <li>Używaj zmiennych środowiskowych do konfiguracji wrażliwych danych</li>
                <li>Definiuj wolumeny dla trwałego przechowywania danych</li>
                <li>Używaj zależności (<code>depends_on</code>) do określania kolejności uruchamiania usług</li>
                <li>Wykorzystuj healthchecks do zapewnienia, że usługi są gotowe przed uruchomieniem zależnych kontenerów</li>
                <li>Rozważ użycie osobnych plików docker-compose dla różnych środowisk (dev, prod)</li>
                <li>Używaj wersji obrazów, zamiast tagu <code>latest</code>, dla lepszej przewidywalności</li>
            </ul>

            <div class="tip">
                <strong>Wskazówka:</strong> Docker Compose jest świetnym narzędziem do lokalnego rozwoju i testowania, ale dla produkcyjnych wdrożeń rozważ użycie orkiestratorów kontenerów, takich jak Kubernetes lub Docker Swarm.
            </div>

            <a href="./Przyklad.html" class="button">Przykładowy projekt</a>
        </div>
    </div>
</body>
</html>