<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
       // Tworzymy obiekt `obj` zawierający różne typy danych: liczby, tekst, tablicę oraz zagnieżdżony obiekt
let obj = {a: 1, b: 2, str: "txt", arr: [1, 2, 3], info: {o: 1}};

// Tworzymy obiekt `data` zawierający jedną właściwość `test`
let data = {test: 333};

// Używamy Object.assign, aby połączyć obiekty `data` i `obj`, wynik przypisujemy do `result`
// `data` zostaje zmodyfikowany poprzez dodanie właściwości z `obj`
let result = Object.assign(data, obj);

// Wyświetlamy wynik połączenia obiektów
// `result` (i tym samym `data`) zawiera teraz wszystkie właściwości z obiektu `obj`
console.log(result); // {test: 333, a: 1, b: 2, str: "txt", arr: [1, 2, 3], info: {o: 1}}

// Sprawdzamy, czy `data` i `obj` to ten sam obiekt w pamięci
// Wynik: false, ponieważ `data` i `obj` to dwa różne obiekty
console.log(obj === data); // false

// Sprawdzamy, czy tablice `arr` wewnątrz `obj` i `data` odnoszą się do tej samej referencji w pamięci
// Wynik: true, ponieważ Object.assign kopiuje referencję do tablicy, a nie tworzy jej kopii
console.log(obj.arr === data.arr); // true

// Sprawdzamy, czy zagnieżdżony obiekt `info` w `obj` i `data` to ten sam obiekt w pamięci
// Wynik: true, ponieważ Object.assign kopiuje referencję do obiektu, a nie tworzy nowej instancji
console.log(obj.info === data.info); // true

// Tworzymy kilka obiektów `o1`, `o2` i `o3`, każdy z innymi właściwościami
let o1 = {a: 1, b: 2};
let o2 = {c: 10};
let o3 = {txt: "test"};

// Używamy Object.assign, aby połączyć te obiekty w nowy obiekt `obj2`
// `obj2` będzie zawierać właściwości z `o1`, `o2` i `o3`
let obj2 = Object.assign({}, o1, o2, o3);

// Wyświetlamy wynikowy obiekt `obj2`
// `obj2` zawiera wszystkie właściwości z `o1`, `o2` i `o3`
console.log(obj2); // {a: 1, b: 2, c: 10, txt: "test"}


    </script>
</body>
</html>