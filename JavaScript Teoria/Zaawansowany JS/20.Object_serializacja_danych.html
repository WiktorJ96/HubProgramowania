<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // Tworzymy obiekt `source` z różnymi typami danych, w tym stringiem, liczbą, obiektem zagnieżdżonym, tablicą oraz obiektem Date
let source = {
    str: "hello",
    a: 24,
    data: {
        b: 111,
        arr: [1, 2, 3, 4, 5, 6, 7, 8, 9]
    },
    date: new Date(),  // Obiekt typu Date
}

// Używamy `JSON.stringify`, aby przekonwertować obiekt `source` na ciąg JSON
let strData = JSON.stringify(source);
console.log(strData);  
// Wynik: Ciąg JSON, np. '{"str":"hello","a":24,"data":{"b":111,"arr":[1,2,3,4,5,6,7,8,9]},"date":"2024-01-01T12:34:56.789Z"}'
// Ważne: `Date` zostaje przekonwertowany na string w formacie ISO podczas serializacji do JSON

// Używamy `JSON.parse`, aby przekonwertować ciąg JSON z powrotem na obiekt JavaScript
let parsedData = JSON.parse(strData);
console.log(parsedData);  
// Wynik: Obiekt z wartościami odtworzonymi z JSON, ale `date` jest teraz stringiem, a nie obiektem `Date`

// Ręcznie konwertujemy właściwość `date` z powrotem na obiekt typu `Date`
parsedData.date = new Date(parsedData.date);
console.log(parsedData);  
// Wynik: Obiekt `parsedData`, gdzie właściwość `date` jest teraz prawdziwym obiektem `Date`

// Sprawdzamy, czy `parsedData.date` jest instancją obiektu `Date`
console.log(parsedData.date instanceof Date);  // Wynik: true, ponieważ ręcznie skonwertowaliśmy string na obiekt `Date`

// Sprawdzamy, czy `source.date` i `parsedData.date` to ten sam obiekt w pamięci
console.log(source.date === parsedData.date);  // Wynik: false, ponieważ `parsedData.date` to nowy obiekt `Date` utworzony z tej samej wartości, ale nie jest tym samym obiektem co `source.date`

    </script>
</body>
</html>